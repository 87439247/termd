options {
  STATIC = false;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
  ERROR_REPORTING = false;
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(TermInfoParser)

package io.termd.core.term;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class TermInfoParser {

  public TermInfoParser(String s) {
    this(new java.io.StringReader(s));
  }

  public List<String> parseHeaderLine() throws ParseException {
    final List<String> headerLine = new ArrayList<String>();
    parseHeaderLine(new ParserHandler() {
      public void beginHeaderLine(String alias) { headerLine.add(alias); }
      public void addHeader(String alias) { headerLine.add(alias); }
    });
    return headerLine;
  }

  public void parseFeatureLine() throws ParseException {
    parseFeatureLine(new ParserHandler());
  }

  public void parseDevice() throws ParseException {
    parseDevice(new ParserHandler());
  }

  public void parseDatabase() throws ParseException {
    parseDatabase(new ParserHandler());
  }

  private String convertControlChar(String s) {
    char c = s.charAt(0);
    if (c >= 64) {
      if (c >= 'a' && c <= 'z') {
        c = (char)(c - 'a' + 'A' - 64);
      } else {
        c -= 64;
      }
      return String.valueOf(c);
    } else {
        throw new UnsupportedOperationException("Invalid control :" + s);
    }
  }

  private String convertEscChar(String s) {
    char c = s.charAt(0);
    switch (c) {
      case 'e':
      case 'E':
        c = 27;
        break;
      case 'a':
        c = 7;
        break;
      case 'b':
        c = 8;
        break;
      case 'r':
        c = '\r';
        break;
      case 'n':
        c = '\n';
        break;
      case 't':
        c = '\t';
        break;
      case 'f':
        c = 12;
        break;
      case 'A':
        c = 1;
        break;
      case ':':
      case ',':
      case '^':
      case '\\':
        break;
      case 's':
        c = ' ';
        break;
      default:
        throw new UnsupportedOperationException("Invalid escape :" + s);
    }
    return String.valueOf(c);
  }

  // For testing purposes we switch the lexical state before
  public Op parseSingleOp() throws ParseException {
    token_source.SwitchTo(PARSING_STRING_VALUE);
    return parseChar();
  }
}

PARSER_END(TermInfoParser)

<DEFAULT> TOKEN: {
  <#BLANK: [" ","\t"]> |
  <#END_FEATURE: ","(<BLANK>)*>
}

<DEFAULT> TOKEN: {
  <START_FEATURE_LINE: <BLANK>> : PARSING_FEATURE_LINE |
  <START_HEADER_LINE: (["!"-"\""]|["$"-"+"]|["-"-"{"]|["}"-"~"])([" "-"+"]|["-"-"{"]|["}"-"~"]|("," ~["\n"]))*> : PARSING_HEADER_LINE |
  <START_COMMENT_LINE: "#"> : PARSING_COMMENT |
  <EMPTY_LINE: "\n">
}

<PARSING_HEADER_LINE> TOKEN: {
  <HEADER_VALUE: ([" "-"\""]|["$"-"+"]|["-"-"{"]|["}"-"~"])([" "-"+"]|["-"-"{"]|["}"-"~"]|("," ~["\n"]))*> |
  <START_HEADER: "|"> |
  <END_HEADER_LINE: "," "\n"> : DEFAULT
}

<PARSING_COMMENT> TOKEN: {
  <ANY_CHAR: ~["\n"]> |
  <END_COMMENT_LINE: "\n"> : DEFAULT
}

<PARSING_FEATURE_LINE> TOKEN: {
  <START_FEATURE: (["\t"," "])* (["!"-"\""] | ["$"-"+"] | ["-"-"<"] | [">"-"]"] | ["_"-"~"])+> : PARSING_FEATURE_VALUE |
  <END_FEATURE_LINE: (<BLANK>)*"\n"> : DEFAULT
}

<PARSING_FEATURE_VALUE> TOKEN: {
  <START_STRING_VALUE: "="> : PARSING_STRING_VALUE |
  <START_NUMERIC_VALUE: "#"> : PARSING_NUMERIC_VALUE |
  <END_BOOLEAN_VALUE: <END_FEATURE>> : PARSING_FEATURE_LINE
}

<PARSING_STRING_VALUE> TOKEN: {
  <STRING_CHAR: ([" "-"$"] | "&" | ["("-"+"] | ["-"-"["] | ["]"] | ["_"-"~"])+> |
  <STRING_QUOTE: "'"> |
  <STRING_ESC: ["\\"]> : PARSING_STRING_ESC |
  <STRING_CARET: ["^"]> : PARSING_STRING_CARET |
  <OP_PUSH_PARAM: "%p" ["1"-"9"]> |
  <OP_PRINTF: "%" (":")? (["-","+","#"," "])? (["0"-"9"])* ("."(["0"-"9"])+)? (["d","o","x","X","s"])? > |
  <OP_INTEGER_CONSTANT: "%{" ( ["0"-"9"] )+ "}" > |
  <OP_AND: "%&"> |
  <OP_OR: "%|"> |
  <OP_XOR: "%^"> |
  <OP_ESC: "%%"> |
  <OP_PRINT_POP: "%" ["c","s"]> |
  <OP_SET_POP_VARIABLE: "%P" ["A"-"Z","a"-"z"]> |
  <OP_GET_PUSH_VARIABLE: "%g" ["A"-"Z","a"-"z"]> |
  <OP_CHAR_CONSTANT: "%'"> |
  <OP_PUSH_STRLEN: "%l"> |
  <OP_ARITHMETIC_PLUS: "%+"> |
  <OP_ARITHMETIC_MINUS: "%-"> |
  <OP_ARITHMETIC_MUL: "%*"> |
  <OP_ARITHMETIC_DIV: "%/"> |
  <OP_ARITHMETIC_MOD: "%m"> |
  <OP_LOGICAL_EQ: "%="> |
  <OP_LOGICAL_GT: "%>"> |
  <OP_LOGICAL_LT: "%<"> |
  <OP_LOGICAL_AND: "%A"> |
  <OP_LOGICAL_OR: "%O"> |
  <OP_LOGICAL_NEG: "%" ["~","!"]> |
  <OP_EXPR_IF: "%?"> |
  <OP_EXPR_THEN: "%t"> |
  <OP_EXPR_ELSE: "%e"> |
  <OP_EXPR_FI: "%;"> |
  <END_STRING_VALUE : <END_FEATURE>> : PARSING_FEATURE_LINE
}

<PARSING_STRING_ESC> TOKEN: {
  <ANY_ESC_VALUE: ["A","E","a","b","e","f","n","r","s","t",",","\\",":","^"]> : PARSING_STRING_VALUE |
  <#OCTAL_DIGIT: ["0"-"7"]> |
  <ESC_ZERO_OCTAL: "0" (<OCTAL_DIGIT><OCTAL_DIGIT>)?> : PARSING_STRING_VALUE |
  <ESC_OTHER_OCTAL: ["1"-"7"] (<OCTAL_DIGIT><OCTAL_DIGIT>)?> : PARSING_STRING_VALUE
}

<PARSING_STRING_CARET> TOKEN: {
  <ANY_CARET_VALUE: ["A"-"Z","a"-"z","_","^","\\","]"]> : PARSING_STRING_VALUE
}

<PARSING_NUMERIC_VALUE> TOKEN: {
  <DEC_VALUE: ["1"-"9"](["0"-"9"])*> |
  <OCT_VALUE: (["0"-"7"])+> |
  <HEX_VALUE: "0x" (["0"-"9","A"-"F","a"-"f"])+> |
  <END_NUMERIC_VALUE : <END_FEATURE>> : PARSING_FEATURE_LINE
}

void parseDatabase(ParserHandler handler):
{}
{
  ( parseDevice(handler) | parseCommentLine() | <EMPTY_LINE> ) *
  { handler.endDatabase(); }
}

void parseDevice(ParserHandler handler):
{}
{
  parseHeaderLine(handler)
  ( parseFeatureLine(handler) ) *
  { handler.endDevice(); }
}

void parseCommentLine():
{}
{
  <START_COMMENT_LINE> ( <ANY_CHAR> ) * <END_COMMENT_LINE>
}

void parseHeaderLine(ParserHandler handler):
{ Token alias; }
{
  alias=<START_HEADER_LINE> { handler.beginHeaderLine(alias.image); } ( <START_HEADER> alias=<HEADER_VALUE> { handler.addHeader(alias.image); } ) *  <END_HEADER_LINE>
  { handler.endHeaderLine(); }
}

void parseFeatureLine(ParserHandler handler):
{}
{
  ( <START_FEATURE_LINE> ( parseFeature(handler) ) + <END_FEATURE_LINE> )
}

void parseFeature(ParserHandler handler):
{ Token name; }
{
  name=<START_FEATURE> ( parseBooleanFeature(name.image, handler) | parseStringFeature(name.image, handler) | parseNumericFeature(name.image, handler) )
}

void parseBooleanFeature(String name, ParserHandler handler):
{}
{
  <END_BOOLEAN_VALUE> {
    if (name.endsWith("@")) {
      handler.addBooleanFeature(name.substring(0, name.length() - 1), false);
    } else {
      handler.addBooleanFeature(name, true);
    }
  }
}

void parseStringFeature(String name, ParserHandler handler):
{ List<Op> value = new ArrayList<Op>(); Op op; }
{
  try {
    <START_STRING_VALUE> (
      op=parseChar()
      {
        if (op instanceof Op.Constant && value.size() > 0 && value.get(value.size() - 1) instanceof Op.Constant) {
          value.set(value.size() - 1, new Op.Constant("" + value.get(value.size() - 1) + op));
        } else {
          value.add(op);
        }
      }
    ) * <END_STRING_VALUE>
    { handler.addStringFeature(name, new StringValue(value)); }
  } catch (ParseException e) {
    // Deep error recovery
    System.out.println("Coult not parse feature " + name);
    Token t;
    do {
      t = getNextToken();
    }
    while (t.kind != END_STRING_VALUE);
  }
}

Op parseChar():
{ Op op; }
{
  ( op=parseLiteral() | op=parseOp() ) { return op; }
}

Op.Constant parseLiteral():
{ Op.Constant op;Token t; }
{ ( t=<STRING_CHAR> { op=new Op.Constant(t.image); } |
    <STRING_QUOTE> { op=new Op.Constant("'"); } |
    ( <STRING_ESC> (
      ( t=<ANY_ESC_VALUE> { op=new Op.Constant(convertEscChar(t.image)); } ) |
        t=<ESC_ZERO_OCTAL> { op=new Op.Constant(Character.toString((char) Integer.parseInt(t.image, 8))); } |
        t=<ESC_OTHER_OCTAL> { op=new Op.Constant(Character.toString((char) Integer.parseInt(t.image, 8))); }
      )
    ) |
    ( <STRING_CARET> t=<ANY_CARET_VALUE> { op=new Op.Constant(convertControlChar(t.image)); } )
  )
  { return op; }
}

Op parseOp():
{ Op op; }
{ ( op=parseOpPushParam() |
    op=parseOpPrintf() |
    op=parseOpIntegerConstant() |
    op=parseOpBit() |
    op=parseOpArithmetic() |
    op=parseOpLogical() |
    op=parseOpEsc() |
    op=parseOpPushStrLen() |
    op=parseOpPrintPop() |
    op=parseOpVariable() |
    op=parseOpConstant() |
    op=parseOpExpr()
  )
  { return op; }
}

Op.If parseOpExpr():
{ Op op;List<Op> expr=new ArrayList<Op>();Op.Then thenPart; }
{ ( <OP_EXPR_IF> (op=parseChar(){expr.add(op);})+ thenPart=parseThen() <OP_EXPR_FI> )
  { return new Op.If(expr,thenPart); }
}

Op.Then parseThen():
{ Op op;List<Op> expr=new ArrayList<Op>();List<Op> elseExpr=new ArrayList<Op>();ElsePart elsePart=null;Op.Then thenPart; }
{  <OP_EXPR_THEN> (op=parseChar(){expr.add(op);})+
  (
    <OP_EXPR_ELSE> (op=parseChar(){elseExpr.add(op);})+ {elsePart=new Op.Else(elseExpr);} (thenPart=parseThen(){elsePart=new Op.If(elseExpr,thenPart);})?
  )?
  { return new Op.Then(expr,elsePart); }
}

Op.Bit parseOpBit():
{ Op.Bit op; }
{ ( <OP_AND> { op=Op.Bit.AND; } | <OP_OR> { op=Op.Bit.OR; } | <OP_XOR> { op=Op.Bit.XOR; } )
  { return op; }
}

Op.Arithmetic parseOpArithmetic():
{ Op.Arithmetic op; }
{ ( <OP_ARITHMETIC_PLUS> { op=Op.Arithmetic.PLUS; } |
    <OP_ARITHMETIC_MINUS> { op=Op.Arithmetic.MINUS; } |
    <OP_ARITHMETIC_MUL> { op=Op.Arithmetic.MUL; } |
    <OP_ARITHMETIC_DIV> { op=Op.Arithmetic.DIV; } |
    <OP_ARITHMETIC_MOD> { op=Op.Arithmetic.MOD; } )
  { return op; }
}

Op.Logical parseOpLogical():
{ Op.Logical op; }
{ ( <OP_LOGICAL_EQ> { op=Op.Logical.EQ; } |
    <OP_LOGICAL_GT> { op=Op.Logical.GT; } |
    <OP_LOGICAL_LT> { op=Op.Logical.LT; } |
    <OP_LOGICAL_AND> { op=Op.Logical.AND; } |
    <OP_LOGICAL_OR> { op=Op.Logical.OR; } |
    <OP_LOGICAL_NEG> { op=Op.Logical.NEG; }
  )
  { return op; }
}

Op.Esc parseOpEsc():
{ Op.Esc op; }
{ ( <OP_ESC> { op=Op.Esc.INSTANCE; } )
  { return op; }
}

Op.PushStrLen parseOpPushStrLen():
{ Op.PushStrLen op; }
{ ( <OP_PUSH_STRLEN> { op=Op.PushStrLen.INSTANCE; } )
  { return op; }
}

Op.PushParam parseOpPushParam():
{ Token t; }
{ t=<OP_PUSH_PARAM>
  { return new Op.PushParam(t.image.charAt(2) - '0'); }
}

Op.IntegerConstant parseOpIntegerConstant():
{ Token t; }
{ t=<OP_INTEGER_CONSTANT>
  { return new Op.IntegerConstant(Integer.parseInt(t.image.substring(2, t.image.length() - 1))); }
}

Op parseOpPrintf():
{ Token t; }
{
  t=<OP_PRINTF>
  {
    switch(t.image) {
      case "%s":
        return Op.PrintPop.s;
      case "%+":
        return Op.Arithmetic.PLUS;
      case "%-":
        return Op.Arithmetic.MINUS;
      default:
        return Op.Printf.parse(t.image);
    }
  }
}

Op.PrintPop parseOpPrintPop():
{ Token t; }
{
  t=<OP_PRINT_POP>
  { return t.image.charAt(1) == 'c' ? Op.PrintPop.c : Op.PrintPop.s; }
}

Op parseOpVariable():
{ Token t;}
{
  t=<OP_SET_POP_VARIABLE> { return new Op.SetPopVar(t.image.charAt(2)); } |
  t=<OP_GET_PUSH_VARIABLE> { return new Op.GetPushVar(t.image.charAt(2)); }
}

Op.Constant parseOpConstant():
{ Op.Constant op; }
{
  <OP_CHAR_CONSTANT> op=parseLiteral() <STRING_QUOTE>
  { return op;  }
}

void parseNumericFeature(String name, ParserHandler handler):
{ Token t; }
{
  ( <START_NUMERIC_VALUE> (
    t=<HEX_VALUE> { handler.addNumericFeature(name, Integer.parseInt(t.image.substring(2), 16)); } |
    t=<OCT_VALUE> { handler.addNumericFeature(name, Integer.parseInt(t.image, 8)); } |
    t=<DEC_VALUE> { handler.addNumericFeature(name, Integer.parseInt(t.image)); }
  ) <END_NUMERIC_VALUE> )
}

