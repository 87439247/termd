options {
  STATIC = false;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
  ERROR_REPORTING = false;
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(TermInfoParser)

package io.termd.core.term;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class TermInfoParser {

  public TermInfoParser(String s) {
    this(new java.io.StringReader(s));
  }

  public List<String> parseHeaderLine() throws ParseException {
    final List<String> headerLine = new ArrayList<String>();
    parseHeaderLine(new ParserHandler() {
      public void beginHeaderLine(String alias) { headerLine.add(alias); }
      public void addHeader(String alias) { headerLine.add(alias); }
    });
    return headerLine;
  }

  public void parseFeatureLine() throws ParseException {
    parseFeatureLine(new ParserHandler());
  }

  public void parseDevice() throws ParseException {
    parseDevice(new ParserHandler());
  }

  public void parseDatabase() throws ParseException {
    parseDatabase(new ParserHandler());
  }

  private String convertControlChar(String s) {
    char c = s.charAt(0);
    if (c >= 64) {
      if (c >= 'a' && c <= 'z') {
        c = (char)(c - 'a' + 'A' - 64);
      } else {
        c -= 64;
      }
      return String.valueOf(c);
    } else {
        throw new UnsupportedOperationException("Invalid control :" + s);
    }
  }

  private String convertEscChar(String s) {
    char c = s.charAt(0);
    switch (c) {
      case 'e':
      case 'E':
        c = 27;
        break;
      case 'a':
        c = 7;
        break;
      case 'b':
        c = 8;
        break;
      case 'r':
        c = '\r';
        break;
      case 'n':
        c = '\n';
        break;
      case 't':
        c = '\t';
        break;
      case 'f':
        c = 12;
        break;
      case 'A':
        c = 1;
        break;
      case ':':
      case ',':
      case '^':
      case '\\':
        break;
      case 's':
        c = ' ';
        break;
      default:
        throw new UnsupportedOperationException("Invalid escape :" + s);
    }
    return String.valueOf(c);
  }

  // For testing purposes we switch the lexical state before
  public Op parseOp() throws ParseException {
    token_source.SwitchTo(PARSING_STRING_OP);
    return _parseOp();
  }
}

PARSER_END(TermInfoParser)

<DEFAULT> TOKEN: {
  <#BLANK: [" ","\t"]> |
  <#END_FEATURE: ","(<BLANK>)*>
}

<DEFAULT> TOKEN: {
  <START_FEATURE_LINE: <BLANK>> : PARSING_FEATURE_LINE |
  <START_HEADER_LINE: (["!"-"\""]|["$"-"+"]|["-"-"{"]|["}"-"~"])([" "-"+"]|["-"-"{"]|["}"-"~"]|("," ~["\n"]))*> : PARSING_HEADER_LINE |
  <START_COMMENT_LINE: "#"> : PARSING_COMMENT |
  <EMPTY_LINE: "\n">
}

<PARSING_HEADER_LINE> TOKEN: {
  <HEADER_VALUE: ([" "-"\""]|["$"-"+"]|["-"-"{"]|["}"-"~"])([" "-"+"]|["-"-"{"]|["}"-"~"]|("," ~["\n"]))*> |
  <START_HEADER: "|"> |
  <END_HEADER_LINE: "," "\n"> : DEFAULT
}

<PARSING_COMMENT> TOKEN: {
  <ANY_CHAR: ~["\n"]> |
  <END_COMMENT_LINE: "\n"> : DEFAULT
}

<PARSING_FEATURE_LINE> TOKEN: {
  <START_FEATURE: (["\t"," "])* (["!"-"\""] | ["$"-"+"] | ["-"-"<"] | [">"-"]"] | ["_"-"~"])+> : PARSING_FEATURE_VALUE |
  <END_FEATURE_LINE: (<BLANK>)*"\n"> : DEFAULT
}

<PARSING_FEATURE_VALUE> TOKEN: {
  <START_STRING_VALUE: "="> : PARSING_STRING_VALUE |
  <START_NUMERIC_VALUE: "#"> : PARSING_NUMERIC_VALUE |
  <END_BOOLEAN_VALUE: <END_FEATURE>> : PARSING_FEATURE_LINE
}

<PARSING_STRING_VALUE> TOKEN: {
  <STRING_CHAR: ([" "-"$"] | ["&"-"+"] | ["-"-"["] | ["]"] | ["_"-"~"])*> |
  <STRING_ESC: ["\\"]> : PARSING_STRING_ESC |
  <STRING_CARET: ["^"]> : PARSING_STRING_CARET |
  <STRING_OP: ["%"]> : PARSING_STRING_OP |
  <END_STRING_VALUE : <END_FEATURE>> : PARSING_FEATURE_LINE
}

<PARSING_STRING_ESC> TOKEN: {
  <ANY_ESC_VALUE: ["A","E","a","b","e","f","n","r","s","t",",","\\",":","^"]> : PARSING_STRING_VALUE |
  <#OCTAL_DIGIT: ["0"-"7"]> |
  <ESC_ZERO_OCTAL: "0" (<OCTAL_DIGIT><OCTAL_DIGIT>)?> : PARSING_STRING_VALUE |
  <ESC_OTHER_OCTAL: ["1"-"7"] (<OCTAL_DIGIT><OCTAL_DIGIT>)?> : PARSING_STRING_VALUE
}

<PARSING_STRING_CARET> TOKEN: {
  <ANY_CARET_VALUE: ["A"-"Z","a"-"z","_","^","\\","]"]> : PARSING_STRING_VALUE
}

<PARSING_NUMERIC_VALUE> TOKEN: {
  <DEC_VALUE: ["1"-"9"](["0"-"9"])*> |
  <OCT_VALUE: (["0"-"7"])+> |
  <HEX_VALUE: "0x" (["0"-"9","A"-"F","a"-"f"])+> |
  <END_NUMERIC_VALUE : <END_FEATURE>> : PARSING_FEATURE_LINE
}

<PARSING_STRING_OP> TOKEN: {
  <OP_PUSH_PARAM: "p" ["1"-"9"]> : PARSING_STRING_VALUE |
  <OP_PRINTF: (":")? (["-","+","#"," "])? (["0"-"9"])* ("."(["0"-"9"])+)? (["d","o","x","X","s"])? > : PARSING_STRING_VALUE |
  <OP_INTEGER_CONSTANT: "{" ( ["0"-"9"] )+ "}" > : PARSING_STRING_VALUE |
  <OP_AND: "&"> : PARSING_STRING_VALUE |
  <OP_OR: "|"> : PARSING_STRING_VALUE |
  <OP_XOR: "^"> : PARSING_STRING_VALUE |
  <OP_ESC: "%"> : PARSING_STRING_VALUE |
  <OP_PRINT_POP: ["c","s"]> : PARSING_STRING_VALUE |
  <OP_SET_POP_VARIABLE: "P" ["A"-"Z","a"-"z"]> : PARSING_STRING_VALUE |
  <OP_GET_PUSH_VARIABLE: "g" ["A"-"Z","a"-"z"]> : PARSING_STRING_VALUE |
  <OP_CHAR_CONSTANT: "'" ~[]  "'"> : PARSING_STRING_VALUE |
  <OP_STRLEN: "l"> : PARSING_STRING_VALUE |
  <OP_ARITHMETIC_PLUS: "+"> : PARSING_STRING_VALUE |
  <OP_ARITHMETIC_MINUS: "-"> : PARSING_STRING_VALUE |
  <OP_ARITHMETIC_MUL: "*"> : PARSING_STRING_VALUE |
  <OP_ARITHMETIC_DIV: "/"> : PARSING_STRING_VALUE |
  <OP_ARITHMETIC_MOD: "m"> : PARSING_STRING_VALUE |
  <OP_LOGICAL_EQ: "="> : PARSING_STRING_VALUE |
  <OP_LOGICAL_GT: ">"> : PARSING_STRING_VALUE |
  <OP_LOGICAL_LT: "<"> : PARSING_STRING_VALUE |
  <OP_LOGICAL_AND: "A"> : PARSING_STRING_VALUE |
  <OP_LOGICAL_OR: "O"> : PARSING_STRING_VALUE |
  <OP_LOGICAL_NEG: ["~","!"]> : PARSING_STRING_VALUE |
  <OP_EXPR_IF: "?"> : PARSING_STRING_VALUE |
  <OP_EXPR_THEN: "t"> : PARSING_STRING_VALUE |
  <OP_EXPR_ELSE: "e"> : PARSING_STRING_VALUE |
  <OP_EXPR_FI: ";"> : PARSING_STRING_VALUE
}

void parseDatabase(ParserHandler handler):
{}
{
  ( parseDevice(handler) | parseCommentLine() | <EMPTY_LINE> ) *
  { handler.endDatabase(); }
}

void parseDevice(ParserHandler handler):
{}
{
  parseHeaderLine(handler)
  ( parseFeatureLine(handler) ) *
  { handler.endDevice(); }
}

void parseCommentLine():
{}
{
  <START_COMMENT_LINE> ( <ANY_CHAR> ) * <END_COMMENT_LINE>
}

void parseHeaderLine(ParserHandler handler):
{ Token alias; }
{
  alias=<START_HEADER_LINE> { handler.beginHeaderLine(alias.image); } ( <START_HEADER> alias=<HEADER_VALUE> { handler.addHeader(alias.image); } ) *  <END_HEADER_LINE>
  { handler.endHeaderLine(); }
}

void parseFeatureLine(ParserHandler handler):
{}
{
  <START_FEATURE_LINE> ( parseFeature(handler) ) + <END_FEATURE_LINE>
}

void parseFeature(ParserHandler handler):
{ Token name; }
{
  name=<START_FEATURE> ( parseBooleanFeature(name.image, handler) | parseStringFeature(name.image, handler) | parseNumericFeature(name.image, handler) )
}

void parseBooleanFeature(String name, ParserHandler handler):
{}
{
  <END_BOOLEAN_VALUE> {
    if (name.endsWith("@")) {
      handler.addBooleanFeature(name.substring(0, name.length() - 1), false);
    } else {
      handler.addBooleanFeature(name, true);
    }
  }
}

void parseStringFeature(String name, ParserHandler handler):
{ StringBuilder val = new StringBuilder(); Token c; }
{
  <START_STRING_VALUE> (
    c=<STRING_CHAR> { val.append(c.image); } |
    ( <STRING_ESC> (
      ( c=<ANY_ESC_VALUE> { val.append(convertEscChar(c.image)); } ) |
      c=<ESC_ZERO_OCTAL> { val.append((char)Integer.parseInt(c.image, 8)); } |
      c=<ESC_OTHER_OCTAL> { val.append((char)Integer.parseInt(c.image, 8)); } ) ) |
    ( <STRING_CARET> c=<ANY_CARET_VALUE> { val.append(convertControlChar(c.image)); } ) |
    ( <STRING_OP> _parseOp()
    )
  ) * <END_STRING_VALUE>
  { handler.addStringFeature(name, val.toString()); }
}

Op _parseOp():
{ Op op; }
{ ( op=parseOpPushParam() |
    op=parseOpPrintf() |
    op=parseOpIntegerConstant() |
    op=parseOpBit() |
    op=parseOpArithmetic() |
    op=parseOpLogical() |
    op=parseOpEsc() |
    op=parseOpStrLen() |
    op=parseOpPrintPop() |
    op=parseOpVariable() |
    op=parseOpCharConstant() |
    op=parseOpExpr()
  )
  { return op; }
}

Op.Bit parseOpBit():
{ Op.Bit op; }
{ ( <OP_AND> { op=Op.Bit.AND; } | <OP_OR> { op=Op.Bit.OR; } | <OP_XOR> { op=Op.Bit.XOR; } )
  { return op; }
}

Op.Arithmetic parseOpArithmetic():
{ Op.Arithmetic op; }
{ ( <OP_ARITHMETIC_PLUS> { op=Op.Arithmetic.PLUS; } |
    <OP_ARITHMETIC_MINUS> { op=Op.Arithmetic.MINUS; } |
    <OP_ARITHMETIC_MUL> { op=Op.Arithmetic.MUL; } |
    <OP_ARITHMETIC_DIV> { op=Op.Arithmetic.DIV; } |
    <OP_ARITHMETIC_MOD> { op=Op.Arithmetic.MOD; } )
  { return op; }
}

Op.Logical parseOpLogical():
{ Op.Logical op; }
{ ( <OP_LOGICAL_EQ> { op=Op.Logical.EQ; } |
    <OP_LOGICAL_GT> { op=Op.Logical.GT; } |
    <OP_LOGICAL_LT> { op=Op.Logical.LT; } |
    <OP_LOGICAL_AND> { op=Op.Logical.AND; } |
    <OP_LOGICAL_OR> { op=Op.Logical.OR; } |
    <OP_LOGICAL_NEG> { op=Op.Logical.NEG; }
  )
  { return op; }
}

Op.Expr parseOpExpr():
{ Op.Expr op; }
{ ( <OP_EXPR_IF> { op=Op.Expr.IF; } |
    <OP_EXPR_THEN> { op=Op.Expr.THEN; } |
    <OP_EXPR_ELSE> { op=Op.Expr.ELSE; } |
    <OP_EXPR_FI> { op=Op.Expr.FI; }
  )
  { return op; }
}

Op.Esc parseOpEsc():
{ Op.Esc op; }
{ ( <OP_ESC> { op=Op.Esc.INSTANCE; } )
  { return op; }
}

Op.StrLen parseOpStrLen():
{ Op.StrLen op; }
{ ( <OP_STRLEN> { op=Op.StrLen.INSTANCE; } )
  { return op; }
}

Op.PushParam parseOpPushParam():
{ Token t; }
{ t=<OP_PUSH_PARAM>
  { return new Op.PushParam(t.image.charAt(1) - '0'); }
}

Op.IntegerConstant parseOpIntegerConstant():
{ Token t; }
{ t=<OP_INTEGER_CONSTANT>
  { return new Op.IntegerConstant(Integer.parseInt(t.image.substring(1, t.image.length() - 1))); }
}

Op parseOpPrintf():
{ Token t; }
{
  t=<OP_PRINTF>
  {
    switch(t.image) {
      case "s":
        return Op.PrintPop.s;
      case "+":
        return Op.Arithmetic.PLUS;
      case "-":
        return Op.Arithmetic.MINUS;
      default:
        return Op.Printf.parse(t.image);
    }
  }
}

Op.PrintPop parseOpPrintPop():
{ Token t; }
{
  t=<OP_PRINT_POP>
  { return t.image.charAt(0) == 'c' ? Op.PrintPop.c : Op.PrintPop.s; }
}

Op parseOpVariable():
{ Token t;}
{
  t=<OP_SET_POP_VARIABLE> { return new Op.SetPopVar(t.image.charAt(1)); } |
  t=<OP_GET_PUSH_VARIABLE> { return new Op.GetPushVar(t.image.charAt(1)); }
}

Op.CharConstant parseOpCharConstant():
{ Token t;}
{
  t=<OP_CHAR_CONSTANT>
  { return new Op.CharConstant(t.image.charAt(1));  }
}

void parseNumericFeature(String name, ParserHandler handler):
{ Token t; }
{
  ( <START_NUMERIC_VALUE> (
    t=<HEX_VALUE> { handler.addNumericFeature(name, Integer.parseInt(t.image.substring(2), 16)); } |
    t=<OCT_VALUE> { handler.addNumericFeature(name, Integer.parseInt(t.image, 8)); } |
    t=<DEC_VALUE> { handler.addNumericFeature(name, Integer.parseInt(t.image)); }
  ) <END_NUMERIC_VALUE> )
}

